// MIT License
//
// Copyright (c) 2025 SlickQuant
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// ********** THIS FILE IS AUTO-GENERATED FROM src/logger.hpp **********
// ********** DO NOT EDIT THIS FILE DIRECTLY                  **********
// ********** EDIT src/logger.hpp AND RE-RUN CMAKE TO UPDATE  **********


#pragma once

#include <string>
#include <cstdint>
#include <thread>
#include <atomic>
#include <filesystem>
#include <memory>
#include <functional>
#include <iostream>
#include <fstream>
#include <sstream>
#include <chrono>
#include <iomanip>
#include <ctime>
#include <format>
#include <utility>
#include <vector>
#include <slick_queue/slick_queue.h>

// For time functions on some platforms
#ifdef _WIN32
#include <time.h>
#endif

#define SLICK_LOGGER_VERSION_MAJOR 0
#define SLICK_LOGGER_VERSION_MINOR 1
#define SLICK_LOGGER_VERSION_PATCH 1
#define SLICK_LOGGER_VERSION_TWEAK 1
#define SLICK_LOGGER_VERSION "0.1.1.1"

namespace slick_logger {

enum class LogLevel : uint8_t {
    L_TRACE = 0,
    L_DEBUG = 1,
    L_INFO = 2,
    L_WARN = 3,
    L_ERROR = 4,
    L_FATAL = 5,
    L_OFF = 6,
};

inline constexpr const char* to_string(LogLevel level) noexcept {
    switch (level) {
        case LogLevel::L_TRACE: return "TRACE";
        case LogLevel::L_DEBUG: return "DEBUG";
        case LogLevel::L_INFO:  return "INFO";
        case LogLevel::L_WARN:  return "WARN";
        case LogLevel::L_ERROR: return "ERROR";
        case LogLevel::L_FATAL: return "FATAL";
        case LogLevel::L_OFF:   return "OFF";
        default:              return "UNKNOWN";
    }
}

/**
 * @brief Class to format timestamps in various formats
 */
class TimestampFormatter {
public:
    enum class Format {
        DEFAULT,          // 2024-08-26 15:30:45
        WITH_MICROSECONDS, // 2024-08-26 15:30:45.123456
        WITH_MILLISECONDS, // 2024-08-26 15:30:45.123
        ISO8601,          // 2024-08-26T15:30:45.123456Z
        TIME_ONLY,        // 15:30:45.123456
        CUSTOM            // User-defined format
    };

    TimestampFormatter(Format fmt = Format::WITH_MICROSECONDS) : format_(fmt) {}
    
    TimestampFormatter(const std::string& custom_format) 
        : format_(Format::CUSTOM), custom_format_(custom_format) {}

    std::string format_timestamp(uint64_t timestamp_ns) const {
        using namespace std::chrono;

        nanoseconds duration_ns(timestamp_ns);
        system_clock::time_point time_point(duration_cast<system_clock::duration>(duration_ns));

        time_t time_val = system_clock::to_time_t(time_point);
        std::tm* tm_ptr = std::localtime(&time_val);
        if (!tm_ptr) {
            return "1970-01-01 00:00:00.000000"; // fallback timestamp
        }
        std::tm tm = *tm_ptr;

        // Extract microseconds and milliseconds
        auto microseconds_count = duration_cast<microseconds>(duration_ns).count();
        auto microseconds = microseconds_count % 1000000;
        auto milliseconds = microseconds / 1000;

        std::ostringstream oss;

        switch (format_) {
            case Format::DEFAULT:
                oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
                break;

            case Format::WITH_MICROSECONDS:
                oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S")
                    << "." << std::setfill('0') << std::setw(6) << microseconds;
                break;

            case Format::WITH_MILLISECONDS:
                oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S")
                    << "." << std::setfill('0') << std::setw(3) << milliseconds;
                break;

            case Format::ISO8601:
                oss << std::put_time(&tm, "%Y-%m-%dT%H:%M:%S")
                    << "." << std::setfill('0') << std::setw(6) << microseconds << "Z";
                break;

            case Format::TIME_ONLY:
                oss << std::put_time(&tm, "%H:%M:%S")
                    << "." << std::setfill('0') << std::setw(6) << microseconds;
                break;

            case Format::CUSTOM:
                if (!custom_format_.empty()) {
                    // Handle %f placeholder for microseconds in custom format
                    std::string format = custom_format_;
                    size_t pos = format.find("%f");
                    if (pos != std::string::npos) {
                        format.replace(pos, 2, std::to_string(microseconds));
                    }
                    oss << std::put_time(&tm, format.c_str());
                    return oss.str();
                } else {
                    oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
                }
                break;
        }

        return oss.str();
    }

private:
    Format format_;
    std::string custom_format_;
};

struct LogEntry {
    LogLevel level;
    std::function<std::pair<std::string,bool>()> formatter; // Lambda that returns formatted message
    uint64_t timestamp; // nanoseconds since epoch
};

class ISink {
public:
    virtual ~ISink() = default;
    virtual void write(const LogEntry& entry) = 0;
    virtual void flush() = 0;
};

struct RotationConfig {
    size_t max_file_size = 10 * 1024 * 1024; // 10MB
    size_t max_files = 5;
    bool compress_old = false;
    std::chrono::hours rotation_hour = std::chrono::hours(0); // Daily at midnight
};

class ConsoleSink : public ISink {
public:
    explicit ConsoleSink(bool use_colors = true, bool use_stderr_for_errors = true, 
                        TimestampFormatter::Format timestamp_format = TimestampFormatter::Format::WITH_MICROSECONDS);
    
    explicit ConsoleSink(const std::string& custom_timestamp_format, bool use_colors = true, 
                        bool use_stderr_for_errors = true);

    void write(const LogEntry& entry) override;
    void flush() override;

private:
    std::string format_log_entry(const LogEntry& entry);
    std::string get_color_code(LogLevel level);
    std::string get_reset_code();
    
    bool use_colors_;
    bool use_stderr_for_errors_;
    TimestampFormatter timestamp_formatter_;
};

class FileSink : public ISink {
public:
    explicit FileSink(const std::filesystem::path& file_path, 
                     TimestampFormatter::Format timestamp_format = TimestampFormatter::Format::WITH_MICROSECONDS);
    
    explicit FileSink(const std::filesystem::path& file_path, const std::string& custom_timestamp_format);

    std::string file_path() const noexcept;
    
    void write(const LogEntry& entry) override;
    void flush() override;

protected:
    std::string format_log_entry(const LogEntry& entry);
    
    std::filesystem::path file_path_;
    std::ofstream file_stream_;
    TimestampFormatter timestamp_formatter_;
};

class RotatingFileSink : public FileSink {
public:
    RotatingFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                    TimestampFormatter::Format timestamp_format = TimestampFormatter::Format::WITH_MICROSECONDS);
    
    RotatingFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                    const std::string& custom_timestamp_format);
    
    void write(const LogEntry& entry) override;

private:
    void check_rotation();
    void rotate_files();
    std::filesystem::path get_rotated_filename(size_t index);
    
    RotationConfig config_;
    std::filesystem::path base_path_;
    size_t current_file_size_;
};

class DailyFileSink : public FileSink {
public:
    DailyFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                 TimestampFormatter::Format timestamp_format = TimestampFormatter::Format::WITH_MICROSECONDS);

    DailyFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                 const std::string& custom_timestamp_format);

    void write(const LogEntry& entry) override;

protected:
    void check_rotation();
    virtual std::string get_date_string();

    std::filesystem::path get_daily_filename();
    std::filesystem::path get_dated_filename(const std::string& date);
    std::filesystem::path get_dated_indexed_filename(const std::string& date, size_t index);

    RotationConfig config_;
    std::filesystem::path base_path_;
    std::string current_date_;
    size_t current_file_size_;
    size_t current_day_index_;
};

/**
 * @brief Configuration struct for initializing the logger
 */
struct LogConfig {
    std::vector<std::shared_ptr<ISink>> sinks;
    LogLevel min_level = LogLevel::L_TRACE;
    size_t queue_size = 65536;
};

/**
 * @brief Singleton Logger class
 */
class Logger {
public:
    static Logger& instance();

    /**
     * @brief Initialize the logger with a log file path
     * @param log_file Path to the log file
     * @param queue_size Size of the internal log queue (must be power of 2, default 65536)
     */
    void init(const std::filesystem::path& log_file, size_t queue_size = 65536);

    /**
     * @brief Initialize the logger with a configuration struct
     * @param config LogConfig struct with sinks and settings
     */
    void init(const LogConfig& config);

    /**
     * @brief Initialize logger with pre-added sinks - sinks should be added before calling this
     * @param queue_size Size of the internal log queue (must be power of 2, default 65536)
     */
    void init(size_t queue_size = 65536);
    
    /**
     * @brief Add a log sink
     * @param sink Shared pointer to a sink implementing ISink interface
     */
    void add_sink(std::shared_ptr<ISink> sink);

    /** 
     * @brief Clear all existing sinks
     */
    void clear_sinks();
    
    /**
     * @brief Add a console sink with optional color and error stream settings
     * @param use_colors Whether to use colors in console output (default true)
     * @param use_stderr_for_errors Whether to send warnings and errors to stderr (default true)
     */
    void add_console_sink(bool use_colors = true, bool use_stderr_for_errors = true);

    /**
     * @brief Add a console sink with custom timestamp format and optional color and error stream settings
     * @param timestamp_format Predefined timestamp format enum
     * @param use_colors Whether to use colors in console output (default true)
     * @param use_stderr_for_errors Whether to send warnings and errors to stderr (default true)
     */
    void add_console_sink(TimestampFormatter::Format timestamp_format, bool use_colors = true, bool use_stderr_for_errors = true);

    /**
     * @brief Add a console sink with custom timestamp format string and optional color and error stream settings
     * @param custom_timestamp_format Custom timestamp format string
     * @param use_colors Whether to use colors in console output (default true)
     * @param use_stderr_for_errors Whether to send warnings and errors to stderr (default true)
     */
    void add_console_sink(const std::string& custom_timestamp_format, bool use_colors = true, bool use_stderr_for_errors = true);
    
    /**
     * @brief Add a file sink
     * @param path Path to the log file
     */
    void add_file_sink(const std::filesystem::path& path);

    /**
     * @brief Add a file sink with custom timestamp format
     * @param path Path to the log file
     * @param timestamp_format Predefined timestamp format enum
     */
    void add_file_sink(const std::filesystem::path& path, TimestampFormatter::Format timestamp_format);

    /**
     * @brief Add a file sink with custom timestamp format string
     * @param path Path to the log file
     * @param custom_timestamp_format Custom timestamp format string
     */
    void add_file_sink(const std::filesystem::path& path, const std::string& custom_timestamp_format);
    
    /**
     * @brief Add a rotating file sink
     * @param path Base path to the log file
     * @param config Rotation configuration
     */
    void add_rotating_file_sink(const std::filesystem::path& path, const RotationConfig& config);

    /**
     * @brief Add a rotating file sink with custom timestamp format
     * @param path Base path to the log file
     * @param config Rotation configuration
     * @param timestamp_format Predefined timestamp format enum
     */
    void add_rotating_file_sink(const std::filesystem::path& path, const RotationConfig& config, TimestampFormatter::Format timestamp_format);

    /**
     * @brief Add a rotating file sink with custom timestamp format string
     * @param path Base path to the log file
     * @param config Rotation configuration
     * @param custom_timestamp_format Custom timestamp format string
     */
    void add_rotating_file_sink(const std::filesystem::path& path, const RotationConfig& config, const std::string& custom_timestamp_format);
    
    /**
     * @brief Add a daily file sink
     * @param path Base path to the log file
     * @param config Rotation configuration
     */
    void add_daily_file_sink(const std::filesystem::path& path, const RotationConfig& config = {});

    /**
     * @brief Add a daily file sink with custom timestamp format
     * @param path Base path to the log file
     * @param config Rotation configuration
     * @param timestamp_format Predefined timestamp format enum
     */
    void add_daily_file_sink(const std::filesystem::path& path, const RotationConfig& config, TimestampFormatter::Format timestamp_format);

    /**
     * @brief Add a daily file sink with custom timestamp format string
     * @param path Base path to the log file
     * @param config Rotation configuration
     * @param custom_timestamp_format Custom timestamp format string
     */
    void add_daily_file_sink(const std::filesystem::path& path, const RotationConfig& config, const std::string& custom_timestamp_format);

    /**
     * @brief Get the sink of givent type
     * @return The shared_ptr of the given sink type. It could be null if the sink of give type doesn't exist
     */
    template<typename SinkT>
    std::shared_ptr<ISink> get_sink() const noexcept;

    /**
     * @brief Get the current log level
     * @return Current LogLevel
     */
    LogLevel get_level() const noexcept {
        return log_level_.load(std::memory_order_relaxed);
    }

    /**
     * @brief Set the minimum log level
     * @param level Minimum LogLevel to set
     */
    void set_level(LogLevel level) {
        log_level_.store(level, std::memory_order_release);
    }

    /**
     * @brief Log a message with a specific log level and format
     * @param level LogLevel of the message
     * @param format Format string (printf-style)
     * @param args Arguments for the format string
     */
    template<typename... Args>
    void log(LogLevel level, const std::string& format, Args&&... args);

    /**
     * @brief Shutdown the logger and flush all pending log entries
     * @param clear_sinks Clear sink list
     */
    void shutdown(bool clear_sinks = true);

    /**
     * @brief Reset the logger to uninitialized state
     * Note: This is primarily for testing purposes. Use with caution.
     */
    void reset();

private:
    Logger() = default;
    ~Logger();

    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;
    Logger(Logger&&) = delete;
    Logger& operator=(Logger&&) = delete;

    void start();
    void writer_thread_func();
    void write_log_entry(const LogEntry* entry_ptr, uint32_t count);
    
    // Helper function to round up to next power of 2
    static size_t round_up_to_power_of_2(size_t value) noexcept;

    std::unique_ptr<slick::SlickQueue<LogEntry>> queue_;
    std::vector<std::shared_ptr<ISink>> sinks_;
    std::filesystem::path log_file_;
    std::thread writer_thread_;
    std::atomic<bool> running_{false};
    uint64_t read_index_{0};
    std::atomic<LogLevel> log_level_{LogLevel::L_TRACE};
};

// Implementation (header-only library)

inline ConsoleSink::ConsoleSink(bool use_colors, bool use_stderr_for_errors, 
                                TimestampFormatter::Format timestamp_format)
    : use_colors_(use_colors), use_stderr_for_errors_(use_stderr_for_errors), 
      timestamp_formatter_(timestamp_format) {
}

inline ConsoleSink::ConsoleSink(const std::string& custom_timestamp_format, bool use_colors, 
                                bool use_stderr_for_errors)
    : use_colors_(use_colors), use_stderr_for_errors_(use_stderr_for_errors), 
      timestamp_formatter_(custom_timestamp_format) {
}

inline void ConsoleSink::write(const LogEntry& entry) {
    std::string formatted = format_log_entry(entry);
    
    if (use_stderr_for_errors_ && (entry.level >= LogLevel::L_WARN)) {
        std::cerr << formatted << std::endl;
    } else {
        std::cout << formatted << std::endl;
    }
}

inline void ConsoleSink::flush() {
    std::cout.flush();
    std::cerr.flush();
}

inline std::string ConsoleSink::format_log_entry(const LogEntry& entry) {
    std::string level_str = to_string(entry.level);
    std::string timestamp = timestamp_formatter_.format_timestamp(entry.timestamp);
    auto [message, good] = entry.formatter();
    if (!good) [[unlikely]] {
        level_str = "ERROR";
    }
    std::string result = timestamp + " [" + level_str + "] " + message;
    
    if (use_colors_) {
        return get_color_code(entry.level) + result + get_reset_code();
    }
    
    return result;
}

inline std::string ConsoleSink::get_color_code(LogLevel level) {
    switch (level) {
        case LogLevel::L_TRACE: return "\033[90m";   // Dark gray
        case LogLevel::L_DEBUG: return "\033[36m";   // Cyan
        case LogLevel::L_INFO: return "\033[32m";    // Green
        case LogLevel::L_WARN: return "\033[33m";    // Yellow
        case LogLevel::L_ERROR: return "\033[31m";     // Red
        case LogLevel::L_FATAL: return "\033[91m";   // Bright red
        default: return "";
    }
}

inline std::string ConsoleSink::get_reset_code() {
    return "\033[0m";
}

inline FileSink::FileSink(const std::filesystem::path& file_path, 
                          TimestampFormatter::Format timestamp_format)
    : file_path_(file_path), timestamp_formatter_(timestamp_format) {
    file_stream_.open(file_path_, std::ios::app);
    if (!file_stream_) {
        throw std::runtime_error("Failed to open log file: " + file_path_.string());
    }
}

inline FileSink::FileSink(const std::filesystem::path& file_path, const std::string& custom_timestamp_format)
    : file_path_(file_path), timestamp_formatter_(custom_timestamp_format) {
    file_stream_.open(file_path_, std::ios::app);
    if (!file_stream_) {
        throw std::runtime_error("Failed to open log file: " + file_path_.string());
    }
}

inline void FileSink::write(const LogEntry& entry) {
    if (file_stream_) {
        file_stream_ << format_log_entry(entry) << std::endl;
    }
}

inline void FileSink::flush() {
    if (file_stream_) {
        file_stream_.flush();
    }
}

inline std::string FileSink::format_log_entry(const LogEntry& entry) {
    std::string level_str = to_string(entry.level);
    std::string timestamp = timestamp_formatter_.format_timestamp(entry.timestamp);
    auto [message, good] = entry.formatter();
    if (!good) [[unlikely]] {
        level_str = "ERROR";
    }
    return timestamp + " [" + level_str + "] " + message;
}

inline RotatingFileSink::RotatingFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                                        TimestampFormatter::Format timestamp_format)
    : FileSink(base_path, timestamp_format), config_(config), base_path_(base_path), current_file_size_(0) {
    if (std::filesystem::exists(base_path_)) {
        current_file_size_ = std::filesystem::file_size(base_path_);
    }
}

inline RotatingFileSink::RotatingFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                                        const std::string& custom_timestamp_format)
    : FileSink(base_path, custom_timestamp_format), config_(config), base_path_(base_path), current_file_size_(0) {
    if (std::filesystem::exists(base_path_)) {
        current_file_size_ = std::filesystem::file_size(base_path_);
    }
}

inline void RotatingFileSink::write(const LogEntry& entry) {
    check_rotation();
    
    if (file_stream_) {
        std::string formatted = format_log_entry(entry);
        file_stream_ << formatted << std::endl;
        current_file_size_ += formatted.length() + 1; // +1 for newline
    }
}

inline void RotatingFileSink::check_rotation() {
    if (current_file_size_ >= config_.max_file_size) {
        rotate_files();
    }
}

inline void RotatingFileSink::rotate_files() {
    file_stream_.close();
    
    // Remove the oldest file if it exists
    auto oldest_file = get_rotated_filename(config_.max_files - 1);
    if (std::filesystem::exists(oldest_file)) {
        std::filesystem::remove(oldest_file);
    }
    
    // Rotate existing files
    for (size_t i = config_.max_files - 1; i > 0; --i) {
        auto src = (i == 1) ? base_path_ : get_rotated_filename(i - 1);
        auto dst = get_rotated_filename(i);
        
        if (std::filesystem::exists(src)) {
            std::filesystem::rename(src, dst);
        }
    }
    
    // Create new current file
    file_stream_.open(base_path_, std::ios::out | std::ios::trunc);
    current_file_size_ = 0;
}

inline std::filesystem::path RotatingFileSink::get_rotated_filename(size_t index) {
    std::string filename = base_path_.stem().string() + "_" + std::to_string(index) + base_path_.extension().string();
    return base_path_.parent_path() / filename;
}

inline DailyFileSink::DailyFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                                  TimestampFormatter::Format timestamp_format)
    : FileSink(base_path, timestamp_format), config_(config), base_path_(base_path),
      current_file_size_(0), current_day_index_(0) {
    current_date_ = get_date_string();
    // Initialize file size if file already exists
    if (std::filesystem::exists(base_path_)) {
        current_file_size_ = std::filesystem::file_size(base_path_);
    }
    // Keep logging to base_path (e.g., daily.log) - FileSink constructor already opened it
}

inline DailyFileSink::DailyFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                                  const std::string& custom_timestamp_format)
    : FileSink(base_path, custom_timestamp_format), config_(config), base_path_(base_path),
      current_file_size_(0), current_day_index_(0) {
    current_date_ = get_date_string();
    // Initialize file size if file already exists
    if (std::filesystem::exists(base_path_)) {
        current_file_size_ = std::filesystem::file_size(base_path_);
    }
    // Keep logging to base_path (e.g., daily.log) - FileSink constructor already opened it
}

inline void DailyFileSink::write(const LogEntry& entry) {
    check_rotation();

    if (file_stream_) {
        std::string formatted = format_log_entry(entry);
        file_stream_ << formatted << std::endl;
        current_file_size_ += formatted.length() + 1; // +1 for newline
    }
}

inline void DailyFileSink::check_rotation() {
    std::string today = get_date_string();

    // Check for date-based rotation
    if (today != current_date_) {
        // Close current file
        file_stream_.close();

        // Rename current base file to dated filename (e.g., daily.log -> daily_2025-08-24.log)
        std::filesystem::path old_dated_file = get_dated_filename(current_date_);
        std::error_code ec;
        if (std::filesystem::exists(base_path_)) {
            std::filesystem::rename(base_path_, old_dated_file, ec);
            if (ec) {
                // If rename fails, try copy and remove
                std::filesystem::copy_file(base_path_, old_dated_file, ec);
                if (!ec) {
                    std::filesystem::remove(base_path_, ec);
                }
            }
        }

        // Reset index for new day
        current_day_index_ = 0;

        // Reopen base file for new day's logs
        file_stream_.open(base_path_, std::ios::out | std::ios::trunc); // Start fresh for new day
        if (!file_stream_) {
            throw std::runtime_error("Failed to reopen daily log file: " + base_path_.string());
        }

        current_file_size_ = 0;
        current_date_ = today;
    }

    // Check for size-based rotation
    if (current_file_size_ >= config_.max_file_size) {
        // Close current file
        file_stream_.close();

        // Rename current base file to dated indexed filename (e.g., daily.log -> daily_2025-08-24_001.log)
        std::filesystem::path old_dated_file = get_dated_indexed_filename(current_date_, current_day_index_);
        std::error_code ec;
        if (std::filesystem::exists(base_path_)) {
            std::filesystem::rename(base_path_, old_dated_file, ec);
            if (ec) {
                // If rename fails, try copy and remove
                std::filesystem::copy_file(base_path_, old_dated_file, ec);
                if (!ec) {
                    std::filesystem::remove(base_path_, ec);
                }
            }
        }

        // Increment index for next file
        ++current_day_index_;

        // Reopen base file for new logs
        file_stream_.open(base_path_, std::ios::out | std::ios::trunc);
        if (!file_stream_) {
            throw std::runtime_error("Failed to reopen daily log file: " + base_path_.string());
        }

        current_file_size_ = 0;
        return; // Don't check date rotation if we just did size rotation
    }
}

inline std::filesystem::path DailyFileSink::get_daily_filename() {
    std::string date_str = get_date_string();
    return get_dated_filename(date_str);
}

inline std::filesystem::path DailyFileSink::get_dated_filename(const std::string& date) {
    std::string filename = base_path_.stem().string() + "_" + date + base_path_.extension().string();
    return base_path_.parent_path() / filename;
}

inline std::filesystem::path DailyFileSink::get_dated_indexed_filename(const std::string& date, size_t index) {
    std::ostringstream oss;
    oss << base_path_.stem().string() << "_" << date << "_" << std::setfill('0') << std::setw(3) << index << base_path_.extension().string();
    return base_path_.parent_path() / oss.str();
}

inline std::string DailyFileSink::get_date_string() {
    auto now = std::chrono::system_clock::now();
    time_t time_val = std::chrono::system_clock::to_time_t(now);
    std::tm* tm_ptr = std::localtime(&time_val);
    if (!tm_ptr) {
        return "1970-01-01"; // fallback date
    }
    std::tm tm = *tm_ptr;

    char date_str[11];
    std::strftime(date_str, sizeof(date_str), "%Y-%m-%d", &tm);
    return std::string(date_str);
}

inline Logger& Logger::instance() {
    static Logger instance;
    return instance;
}

inline void Logger::init(const std::filesystem::path& log_file, size_t queue_size) {
    shutdown(); // make sure the logger is stopped
    add_sink(std::make_shared<FileSink>(log_file));
    
    // Ensure queue_size is power of 2
    queue_size = round_up_to_power_of_2(queue_size);

    queue_ = std::make_unique<slick::SlickQueue<LogEntry>>(static_cast<uint32_t>(queue_size));
    log_file_ = log_file;
    start();
}

inline void Logger::start() {
    running_ = true;
    
    // Initialize read_index_ before starting the thread
    read_index_ = queue_->initial_reading_index();
    
    writer_thread_ = std::thread([this]() { writer_thread_func(); });
    
    // Give a small delay to ensure writer thread is started
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
    log(LogLevel::L_INFO, "SlickLogger v{}", SLICK_LOGGER_VERSION);
}

inline void Logger::init(const LogConfig& config) {
    shutdown(); // make sure the logger is stopped

    if (config.sinks.empty()) {
        throw std::runtime_error("No sink. Sinks should be added in the config.");
    }
    
    for (auto& sink : config.sinks) {
        add_sink(sink);
    }
    
    set_level(config.min_level);
    
    // Ensure queue_size is power of 2
    size_t queue_size = round_up_to_power_of_2(config.queue_size);

    queue_ = std::make_unique<slick::SlickQueue<LogEntry>>(static_cast<uint32_t>(queue_size));
    start();
}

inline void Logger::add_sink(std::shared_ptr<ISink> sink) {
    sinks_.push_back(sink);
}

inline void Logger::clear_sinks() {
    sinks_.clear();
}

template<typename SinkT>
inline std::shared_ptr<ISink> Logger::get_sink() const noexcept {
    for (auto &sink : sinks_) {
        if (dynamic_cast<SinkT*>(sink.get()) != nullptr) {
            return sink;
        }
    }
    return nullptr;
}

inline void Logger::init(size_t queue_size) {
    shutdown(false); // make sure the logger is stopped

    if (sinks_.empty()) {
        throw std::runtime_error("No sink. Sinks should be added first before calling this.");
    }

    // Initialize logger with pre-set sinks - sinks should be added before calling this
    // Ensure queue_size is power of 2
    queue_size = round_up_to_power_of_2(queue_size);

    queue_ = std::make_unique<slick::SlickQueue<LogEntry>>(static_cast<uint32_t>(queue_size));
    start();
}

inline void Logger::add_console_sink(bool use_colors, bool use_stderr_for_errors) {
    add_sink(std::make_shared<ConsoleSink>(use_colors, use_stderr_for_errors));
}

inline void Logger::add_console_sink(TimestampFormatter::Format timestamp_format, bool use_colors, bool use_stderr_for_errors) {
    add_sink(std::make_shared<ConsoleSink>(use_colors, use_stderr_for_errors, timestamp_format));
}

inline void Logger::add_console_sink(const std::string& custom_timestamp_format, bool use_colors, bool use_stderr_for_errors) {
    add_sink(std::make_shared<ConsoleSink>(custom_timestamp_format, use_colors, use_stderr_for_errors));
}

inline void Logger::add_file_sink(const std::filesystem::path& path) {
    add_sink(std::make_shared<FileSink>(path));
}

inline void Logger::add_file_sink(const std::filesystem::path& path, TimestampFormatter::Format timestamp_format) {
    add_sink(std::make_shared<FileSink>(path, timestamp_format));
}

inline void Logger::add_file_sink(const std::filesystem::path& path, const std::string& custom_timestamp_format) {
    add_sink(std::make_shared<FileSink>(path, custom_timestamp_format));
}

inline void Logger::add_rotating_file_sink(const std::filesystem::path& path, const RotationConfig& config) {
    add_sink(std::make_shared<RotatingFileSink>(path, config));
}

inline void Logger::add_rotating_file_sink(const std::filesystem::path& path, const RotationConfig& config, TimestampFormatter::Format timestamp_format) {
    add_sink(std::make_shared<RotatingFileSink>(path, config, timestamp_format));
}

inline void Logger::add_rotating_file_sink(const std::filesystem::path& path, const RotationConfig& config, const std::string& custom_timestamp_format) {
    add_sink(std::make_shared<RotatingFileSink>(path, config, custom_timestamp_format));
}

inline void Logger::add_daily_file_sink(const std::filesystem::path& path, const RotationConfig& config) {
    add_sink(std::make_shared<DailyFileSink>(path, config));
}

inline void Logger::add_daily_file_sink(const std::filesystem::path& path, const RotationConfig& config, TimestampFormatter::Format timestamp_format) {
    add_sink(std::make_shared<DailyFileSink>(path, config, timestamp_format));
}

inline void Logger::add_daily_file_sink(const std::filesystem::path& path, const RotationConfig& config, const std::string& custom_timestamp_format) {
    add_sink(std::make_shared<DailyFileSink>(path, config, custom_timestamp_format));
}

// Helper function to convert arguments to owned types
template<typename T>
constexpr auto make_owned_arg(T&& arg) {
    using DecayedT = std::decay_t<T>;
    
    // Convert const char* to std::string to prevent dangling pointers
    if constexpr (std::is_same_v<DecayedT, const char*> || std::is_same_v<DecayedT, char*>) {
        return std::string(arg);
    }
    // Convert string_view to string for safety
    else if constexpr (std::is_same_v<DecayedT, std::string_view>) {
        return std::string(arg);
    }
    // For all other types, use perfect forwarding to preserve value category
    else {
        return std::forward<T>(arg);
    }
}

template<typename... Args>
inline void Logger::log(LogLevel level, const std::string& format, Args&&... args) {
    if (!running_.load(std::memory_order_relaxed) || !queue_ || level < log_level_.load(std::memory_order_relaxed))
    {
        return;
    }

    auto now = std::chrono::system_clock::now();
    auto ns = std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch()).count();

    // Create lambda that captures format and arguments, formats when called
    // Convert all arguments to owned types to prevent dangling pointers
    auto formatter = [format, args_tuple = std::make_tuple(make_owned_arg(std::forward<Args>(args))...)]() mutable -> std::pair<std::string, bool> {
        try {
            if constexpr (sizeof...(Args) == 0) {
                // No arguments provided, return format string as-is to avoid format parsing errors
                return std::make_pair(format, true);
            } else {
                return std::make_pair(std::apply([&format](auto&&... unpacked_args) -> std::string {
                    return std::vformat(format, std::make_format_args(std::forward<decltype(unpacked_args)>(unpacked_args)...));
                }, args_tuple), true);
            }
        } catch (const std::exception& e) {
            // Return original format string with error info if formatting fails
            return std::make_pair(format + " [FORMAT_ERROR: " + e.what() + "]", false);
        } catch (...) {
            // Handle any other exceptions
            return std::make_pair(format + " [FORMAT_ERROR: Unknown exception]", false);
        }
    };

    uint64_t index = queue_->reserve();
    auto &entry_ref = *(*queue_)[index];
    entry_ref.level = level;
    entry_ref.formatter = std::move(formatter);
    entry_ref.timestamp = static_cast<uint64_t>(ns);
    queue_->publish(index);
}

inline void Logger::shutdown(bool clear_sinks) {
    if (running_.load(std::memory_order_relaxed)) {
        running_.store(false, std::memory_order_release);
        if (writer_thread_.joinable()) {
            writer_thread_.join();
        }
    }
    
    if (clear_sinks) {
        // Clear sinks to release file handles and other resources
        sinks_.clear();
    }
    queue_.reset();
}

inline Logger::~Logger() {
    shutdown();
}

inline void Logger::reset() {
    shutdown();
    // Reset all state for fresh initialization
    log_file_.clear();
    read_index_ = 0;
    log_level_.store(LogLevel::L_TRACE);
}

inline void Logger::writer_thread_func() {
    while (running_.load(std::memory_order_relaxed)) {
        auto [entry_ptr, count] = queue_->read(read_index_);
        if (entry_ptr) {
            write_log_entry(entry_ptr, count);
        } else {
            std::this_thread::sleep_for(std::chrono::milliseconds(1)); // Small delay if no data
        }
    }
    
    // Drain remaining messages after running_ becomes false
    while (true) {
        auto [entry_ptr, count] = queue_->read(read_index_);
        if (!entry_ptr || count == 0) {
            break;
        }
        write_log_entry(entry_ptr, count);
    }
}

inline void Logger::write_log_entry(const LogEntry* entry_ptr, uint32_t count) {
    for (uint32_t i = 0; i < count; ++i) {
        const LogEntry& entry = entry_ptr[i];
        
        // Write to all configured sinks
        for (auto& sink : sinks_) {
            if (sink) {
                sink->write(entry);
            }
        }
    }
    
    // Flush all sinks
    for (auto& sink : sinks_) {
        if (sink) {
            sink->flush();
        }
    }
}

inline size_t Logger::round_up_to_power_of_2(size_t value) noexcept {
    if (value & (value - 1)) {
        // Round up to next power of 2
        size_t temp = value;
        temp--;
        temp |= temp >> 1;
        temp |= temp >> 2;
        temp |= temp >> 4;
        temp |= temp >> 8;
        temp |= temp >> 16;
        if constexpr (sizeof(size_t) > 4) {
            temp |= temp >> 32;
        }
        return temp + 1;
    }
    return value; // Already a power of 2
}

} // namespace slick_logger

// Macros for easy logging
#define LOG_TRACE(...) slick_logger::Logger::instance().log(slick_logger::LogLevel::L_TRACE, __VA_ARGS__)
#define LOG_DEBUG(...) slick_logger::Logger::instance().log(slick_logger::LogLevel::L_DEBUG, __VA_ARGS__)
#define LOG_INFO(...) slick_logger::Logger::instance().log(slick_logger::LogLevel::L_INFO, __VA_ARGS__)
#define LOG_WARN(...) slick_logger::Logger::instance().log(slick_logger::LogLevel::L_WARN, __VA_ARGS__)
#define LOG_ERROR(...) slick_logger::Logger::instance().log(slick_logger::LogLevel::L_ERROR, __VA_ARGS__)
#define LOG_FATAL(...) slick_logger::Logger::instance().log(slick_logger::LogLevel::L_FATAL, __VA_ARGS__)
